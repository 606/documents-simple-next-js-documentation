---
title: GraphQL
description: Overview, schema, queries, mutations, subscriptions, and best practices for GraphQL APIs.
keywords: ["graphql", "schema", "queries", "mutations", "subscriptions", "federation"]
---

import { Note } from "@/components/markdown/note"

# GraphQL

<Note>
This page is migrated from your Obsidian note `api/graphql/index.md` and adapted to MDX with preserved examples.
</Note>

## Overview

GraphQL is a query language for APIs that allows clients to request exactly the data they need, making APIs more efficient and flexible.

## Core Concepts

### Schema
- Defines available data and operations
- Strongly typed with SDL (Schema Definition Language)
- Self-documenting API

### Queries
- Read operations to fetch data
- Declarative data fetching
- Nested and related data in a single request

### Mutations
- Write operations to modify data
- Similar to queries but for changes
- Return modified data

### Subscriptions
- Real-time data updates
- WebSocket-based communication
- Push-based data flow

## Schema Definition

### Types

```graphql
type User {
  id: ID!
  name: String!
  email: String!
  posts: [Post!]!
}

type Post {
  id: ID!
  title: String!
  content: String!
  author: User!
  publishedAt: DateTime!
}
```

### Queries

```graphql
type Query {
  users: [User!]!
  user(id: ID!): User
  posts(limit: Int): [Post!]!
}
```

### Mutations

```graphql
type Mutation {
  createUser(input: CreateUserInput!): User!
  updateUser(id: ID!, input: UpdateUserInput!): User!
  deleteUser(id: ID!): Boolean!
}
```

## Query Examples

### Basic Query

```graphql
query {
  user(id: "123") {
    name
    email
  }
}
```

### Nested Query

```graphql
query {
  user(id: "123") {
    name
    posts {
      title
      publishedAt
    }
  }
}
```

### Query with Arguments

```graphql
query {
  posts(limit: 10) {
    title
    author {
      name
    }
  }
}
```

### Mutation

```graphql
mutation {
  createUser(input: {
    name: "John Doe"
    email: "john@example.com"
  }) {
    id
    name
    email
  }
}
```

## Advantages over REST

### Precise Data Fetching
- No over-fetching: get exactly what's needed
- No under-fetching: single request for related data
- Reduced network overhead

### Single Endpoint
- All operations through `/graphql`
- Versioning through schema evolution
- Simplified client-server communication

### Strong Typing
- Compile-time query validation
- Better IDE support and tooling
- Self-documenting APIs

### Real-time Capabilities
- Built-in subscriptions for live data
- WebSocket transport for real-time updates

## Implementation

### Popular Libraries
- **Apollo Server** (Node.js)
- **GraphQL Yoga** (Node.js)
- **Strawberry** (Python)
- **Graphene** (Python)
- **Hot Chocolate** (.NET)

### Schema Stitching & Federation
- Combine multiple GraphQL schemas
- Federation for microservices
- Schema composition across services

## Best Practices

### Schema Design
- Use descriptive field names
- Implement proper pagination
- Handle errors consistently
- Evolve schema without breaking clients

### Security
- Enforce query complexity limits
- Depth limiting and whitelisting
- Authentication and authorization
- Rate limiting and throttling

### Performance
- Use DataLoader-style batching
- Caching at query and field level
- Query optimization and profiling
- Monitoring and metrics

## Deeper Topics

The original note links to specialised GraphQL topics you can migrate separately:

- Schema design
- Resolvers
- Federation
- Subscriptions

For now, this page gives you a comprehensive GraphQL overview integrated into your Next.js docs.
